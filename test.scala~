abstract class Dimension{}

class Scalar extends Dimension{}

// Quantities

import Dimensions._
import QEBase._
import Units._

case class Quantity(value: Term, tp: Term) {
  def times(q: Quantity) = {
    (tp, q.tp) match {
       case (QE(d), QE(e)) => Quantity(QMul(value, q.value), QE(DimMul(d,e)))
       case _ => ???
    }
  }  
}

val acceleration: Quantity = unitof()



// Relations
abstract class Relation(_lhs: Quantity, _rhs: Quantity){
  var _lhsBaseQuantities: Set[BaseQuantity] = Set()
  var _rhsBaseQuantities: Set[BaseQuantity] = Set()

  def getLHSBaseQuantitiesSet(): Set[BaseQuantity] = _lhsBaseQuantities

  def getRHSBaseQuantitiesSet(): Set[BaseQuantity] = _rhsBaseQuantities

  private[this] def getBaseQuantitiesFromQuantity(quantity: Quantity): Set[BaseQuantity] = quantity match {
    case q: BaseQuantity => Set(q)
    case SumQuantity(a, b) => getBaseQuantitiesFromQuantity(a) ++ getBaseQuantitiesFromQuantity(b)
    case ProductQuantity(a, b) => getBaseQuantitiesFromQuantity(a) ++ getBaseQuantitiesFromQuantity(b)
    case AdditiveInverseQuantity(a) => getBaseQuantitiesFromQuantity(a)
    case MultiplicativeInverseQuantity(a) => getBaseQuantitiesFromQuantity(a)
    case _ => Set()
  }

  _lhsBaseQuantities = getBaseQuantitiesFromQuantity(_lhs)
  _rhsBaseQuantities = getBaseQuantitiesFromQuantity(_rhs)
 
  private[this] def isQuantityInQuantity(q1: Quantity, q2: Quantity): Boolean = q2 match {
    case `q1` => true
    case SumQuantity(a, b) => isQuantityInQuantity(q1, a) || isQuantityInQuantity(q1, b)
    case ProductQuantity(a, b) => isQuantityInQuantity(q1, a) || isQuantityInQuantity(q1, b)
    case AdditiveInverseQuantity(a) => isQuantityInQuantity(q1, a)
    case MultiplicativeInverseQuantity(a) => isQuantityInQuantity(q1, a)
    case _ => false
  }

  def lhsHasQuantity(quantity: Quantity): Boolean = isQuantityInQuantity(quantity, _lhs)

  def rhsHasQuantity(quantity: Quantity): Boolean = isQuantityInQuantity(quantity, _rhs)

  def hasQuantity(quantity: Quantity): Boolean =
    lhsHasQuantity(quantity) || rhsHasQuantity(quantity)

  def getLHS(): Quantity = _lhs

  def getRHS(): Quantity = _rhs
}

case class EqualityRelation(_lhs: Quantity, _rhs: Quantity) extends Relation(_lhs, _rhs){}

def isolate_quantity_in_relation(relation: EqualityRelation, quantity: BaseQuantity) {
  if (relation.rhsHasQuantity(quantity) && relation.lhsHasQuantity(quantity)){

  }
  else if (relation.rhsHasQuantity(quantity)){

  }
  else if (relation.lhsHasQuantity(quantity)){

  }else{
    throw new Exception()
  }
}

case class QuantityDecl(name: LocalName, arguments: List[dimension: Dimension)

// MPDs
class MPD(_quantities: Set[QuantityDecl], _relations: Set[Relation])
{
  var _quantityConnections: Map[BaseQuantity, Set[Relation]] = Map()
  var _relationConnections: Map[Relation, Set[BaseQuantity]] = Map()

  for (q <- _quantities)
    for (r <- _relations if r.hasQuantity(q))
      _quantityConnections get q match {
        case None => _quantityConnections = _quantityConnections + (q -> Set(r))
        case Some(a) => _quantityConnections = _quantityConnections + (q -> (a+r))
      }

  for (r <- _relations)
    for (q <- _quantities if r.hasQuantity(q))
      _relationConnections get r match {
        case None => _relationConnections = _relationConnections + (r -> Set(q))
        case Some(a) => _relationConnections = _relationConnections + (r -> (a+q))
      }
}



class MPDModel(_mpd: MPD, _unknowns: Set[LocalName], _parameters: Set[LocalName])
{
/*

[optimisation step]
_in constructor (consider parameters unknowns):
start by going over all unknowns, and check if they're the only in the relations in their connections.

If they are, then see if can isolate the unknown quantity and make it known.

If can't isolate, `consider` it known (can pass to external solver or apply technique to compute value when parameters are given).


if they aren't, then check if there's a cycle in the graph (maze AI approach, keep history of steps and no back tracing). If there is, then can `consider` all quantities in cycle known.

[when parameters provided]
substitute values, repeat all of the above, then pass to solver as appropriate.

 */
}


object HelloWorld {
  def main(args: Array[String]): Unit = {
    println("Hello, world!")
  }
}
